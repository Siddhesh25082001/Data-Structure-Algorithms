# Graph Representation in CPP

The Graphs can be represented in two ways
- Adjacency Matrix
- Adjacency List
---

**1.  Adjacency Matrix**
- For 0 based nodes indexing -> Adjacency Matrix size will be [n][n]
- For 1 based nodes indexing -> Adjacency Matrix size will be [n + 1][n + 1]
--- 
``` CPP

#include<bits/stdc++.h>
using namespace std;

int main(){

    // Getting no of rows and no of colums respectively
    int n, m;
    cin >> n >> m;

    // Declaring a 2-d vector to store the Adjacency Matrix
    vector< vector<int> > adjMatrix(n+1, vector<int> (n+1, 0));
    for(int i=0; i<m; i++){
        int u, v;
        cin >> u >> v;
        adjMatrix[u][v] = 1; // For Directed Graphs -> Only this will be considered
        adjMatrix[v][u] = 1;
    }

    for(auto row: adjMatrix){
        for(auto col: row){
            cout << col << " ";
        }
        cout << endl;
    }

    return  0;
}
```

### Disadvantages of Adjacency Matrix

- If no of node are in range of **10^5**,  the Adjacency Matrix will be of order **10^10** (10^5 * 10^5),  However it is not possible for an array or vector to store above 10^6 locally and 10^7 globally

### Analysis

> **Time Complexity: `O(n^2)`**
> **Space Complexity: `O(n^2)`**
 
 ---
  
**2. Adjacency List**

- For 0 based nodes indexing -> Adjacency Matrix size will be [n]
- For 1 based nodes indexing -> Adjacency Matrix size will be [n + 1]

``` cpp

#include<bits/stdc++.h>
using  namespace  std;

int  main(){

    // Getting no of rows and no of colums respectively
    int n, m;
    cin >> n >> m;

    // Declaring a 1-d vector to store the Adjacency List (without weighted edges)
    vector<int> adjListUnweighted[n+1];
    for(int i=0; i<m; i++){
        int u, v;
        cin >> u >> v;

        adjListUnweighted[u].emplace_back(v); // For Directed Graphs -> Only this will be considered
        adjListUnweighted[v].emplace_back(u);
    }

    for(auto index: adjListUnweighted){
        for(auto adjNode: index){
            cout << adjNode << " ";
        }
        cout << endl;
    }

    // Declaring a 1-d vector to store the Adjacency List (with weighted edges)
    vector< pair<int, int> > adjListWeighted[n+1];

    for(int i=0; i<m; i++){
        int u, v, w;
        cin >> u >> v >> w;

        adjListWeighted[u].emplace_back(make_pair(v, w)); // For Directed Graphs -> Only this will be considered
        adjListWeighted[v].emplace_back(make_pair(u, w));
    }

    for(auto index: adjListWeighted){
        for(auto adjNode: index){
            cout << "(" << adjNode.first << "," << adjNode.second << ")";
        }
        cout << endl;
        }

    return  0;
}

```

### Analysis
> **Time Complexity: `O(n^2)`**
> **Space Complexity: `O(n + 2e)`** // For UnWeighted Edges
> **Space Complexity: `O(n + 2e) + 2e`**  // For Weighted Edges (Extra 2e for weights)