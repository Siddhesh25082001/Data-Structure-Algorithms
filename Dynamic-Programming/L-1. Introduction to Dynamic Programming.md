# Introduction to Dynamic Programming

#### **`Those who cannot remember the past are condemned to repeat it`**

---

### Ways of Solving a Dynamic Programming

1. Memorization Technique (Top - Down Approach)
2. Tabulation Technique (Bottom - Up Approach)

> **Note: Each and every problem should be solved first by Memorization, then optimized it by Tabulation and then further space optimized it**

---

### Nth Fibonnaci Number

- **Fibonnaci No**: A Number formed by the sum of its previous fibonnaci number and its second previous fibonnaci number
- The Corresponding Recurrence Relation for the same would be **`f(n) = f(n-1) + f(n-2)`**

#### 1. Recursive Approach

``` cpp

#include<bits/stdc++.h>
using namespace std;

int fib(int n){

    if(n <= 1){
        return n;
    }

    return fib(n-1) + fib(n-2);
}

int main(){

    cout << fib(5);
    return 0;
}

```

**Analysis of Recursive Solution**

![image](https://user-images.githubusercontent.com/67231450/148643911-775c76af-76f2-4a67-8c9f-0d180b80a380.png)

- f(5) calls for f(4) and f(3)
- f(4) calls for f(3) and f(2)
- f(3) calls for f(2) and f(1)
- f(2) calls for f(1) and f(0)
    - Here (n == 1) where the Recursion has met its base condition and now it will backtrack 

- f(1) returns 1 and f(0) returns 0 and hence 1 (1 + 0) to f(2) 
- f(2) returns 1 to f(3) and f(3) calls for f(1) which in turns is the base condition hence returns 1

**Observation:** 
- Here when we call for f(5), it calls f(4), f(4) call f(3) and eventually hitting the base condition and then backtrack
- The Problem with Recursion was once it has calculated a sub-problem say f(1) or f(2), it just returns the ans to its parent and never remembers it for later use and hence whenever it encounters the same sub-problem, it again solves this sub-problem which was of no use making a time-waste
- Here is what the first way of solving a Dyanamic Programming comes into picture **`Memorization`**

**Problems in the Recursive Solution**

- Solves the sub-problem on its each encounter thereby wasting a hell amount of time
- **Time Complexity: `O(2*n)`** (Huge Time Complexity)
- **Space Complexity: `O(n)`** (Auxillary Stack Space)

---

#### 2. Dynamic Programming Memorization Approach

**Thought Process**

- Step-1: Declare a DP Array of size n+1 with all elements initalize to -1
- Step-2: Stored the solution for a sub-problem in corresponding dp[sub-problem]
- Step-3: Call the Recursive function if and only if that sub-problem is not solved

> **Note: With the help of these three steps, any Recursion problem can be converted into a DP Memorization Type problem**

``` cpp

#include<bits/stdc++.h>
using namespace std;

int fib(int n, vector<int> &dp){

    if(n <= 1){
        return n;
    }

    // Step-3
    if(dp[n] != -1){
        return dp[n];
    }

    // Step-2
    return dp[n] = fib(n-1, dp) + fib(n-2, dp);
}

int main(){

    int n;
    cin >> n;

    // Step-1
    vector<int> dp(n+1, -1);
    
    cout << fib(n, dp);

    return 0;
}

```

**Analysis of DP Memorization Approach**

- **Time Complexity: `O(n)`** (Only distinctive n functions are called)
- **Space Complexity: `O(n) + O(n)`** (Auxillary Stack Space + Array)

> **Observation: DP Memorization Approach brings down the Huge Time Complexity of O(2^n) to O(n)**

---

#### 3. Dynamic Programming Tabulation Approach

**Thought Process**

- Step-1: Declare a DP Array of size n+1 with all elements initalize to -1
- Step-2: Find the Base Condition and its values
- Step-3: Iterate over for remaining conditons that are left after taken into consideration of the base case

``` cpp

#include<bits/stdc++.h>
using namespace std;

int main(){

    int n;
    cin >> n;

    // Step-1
    vector<int> dp(n+1, -1);
    
    // Step-2
    dp[0] = 0, dp[1] = 1;

    // Step-3
    for(int i=2; i<=n; i++){
        dp[i] = dp[i-1] + dp[i+1];
    }

    return 0;
}

```

**Analysis of DP Tabulation Approach**

- **Time Complexity: `O(n)`** (Only distinctive n functions are called)
- **Space Complexity: `O(n)`** (Array)

> **Observation: DP Tabulation Approach cuts down the extra auxillary space for recursion**

---

#### 4. Space-Optimized Approach over Tabulation Approach

**Intuition**

- If observed, we are actually never required the entire dp array 
- All we required for a current n is its previous value and its second previous value
- So, instead of maintaining an entire array, we can simply maintain two variables say previous and second_previous and then update these two variable at each iteration

``` cpp

#include<bits/stdc++.h>
using namespace std;

int main(){

    int n;
    cin >> n;
    
    int previous, secondPrevious;
    secondPrevious = 0, previous = 1;

    for(int i=2; i<=n; i++){
        
        int current;
        current = previous + secondPrevious;
        
        secondPrevious = previous;
        previous = current;
    }
    
    cout << previous;

    return 0;
}

```

**Analysis of DP Tabulation Approach with Space Optimization**

- **Time Complexity: `O(n)`** (Only distinctive n functions are called)
- **Space Complexity: `O(1)`**

> **Observation: DP Tabulation Approach cuts down the extra array space also**